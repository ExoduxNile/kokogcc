from fastapi import FastAPI, Form, HTTPException
from fastapi.responses import StreamingResponse, JSONResponse, HTMLResponse
from fastapi.middleware.cors import CORSMiddleware
import os
import io
import numpy as np
import soundfile as sf
from kokoro_onnx import Kokoro
import warnings

# Suppress warnings
warnings.filterwarnings("ignore", category=UserWarning)
warnings.filterWarnings("ignore", category=FutureWarning)

app = FastAPI()

# Add CORS middleware for external form access
app.add_middleware(
    CORSMiddleware,
    allow_origins=["https://tropley.com","*","https://www.tropley.com"],  # Your frontend origin
    allow_credentials=True,
    allow_methods=["GET", "POST", "OPTIONS"],  # Explicitly include OPTIONS
    allow_headers=["*"],
    expose_headers=["Content-Disposition"]  # Needed for file downloads
)

# Initialize Kokoro model globally
model_path = "models/v1_0/model.onnx"
voices_path = "voices/v1_0/voices-v1.0.bin"
if not os.path.exists(model_path) or not os.path.exists(voices_path):
    raise HTTPException(status_code=500, detail=f"Missing model or voice files: {model_path}, {voices_path}")
kokoro = Kokoro(model_path, voices_path)

# New endpoint to serve a simple HTML page
@app.get("/", response_class=HTMLResponse)
async def serve_hello_world():
    """Serve a simple Hello World HTML page."""
    return """
    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Hello World</title>
    </head>
    <body>
        <h1>Hello World!</h1>
        <p>This is a test page served by the FastAPI server to confirm connectivity.</p>
    </body>
    </html>
    """

def chunk_text(text, chunk_size=500):
    """Split text into fixed-size chunks."""
    words = text.replace('\n', ' ').split()
    chunks = []
    current_chunk = []
    current_size = 0
    for word in words:
        word_size = len(word) + 1
        if current_size + word_size > chunk_size:
            chunks.append(' '.join(current_chunk))
            current_chunk = [word]
            current_size = word_size
        else:
            current_chunk.append(word)
            current_size += word_size
    if current_chunk:
        chunks.append(' '.join(current_chunk))
    return [chunk for chunk in chunks if chunk.strip()]

def validate_language(lang):
    """Validate if the language is supported."""
    supported_languages = set(kokoro.get_languages())
    if lang not in supported_languages:
        raise HTTPException(status_code=400, detail=f"Unsupported language: {lang}. Supported: {', '.join(sorted(supported_languages))}")
    return lang

def validate_voice(voice):
    """Validate single voice."""
    supported_voices = set(kokoro.get_voices())
    if voice not in supported_voices:
        raise HTTPException(status_code=400, detail=f"Unsupported voice: {voice}. Supported: {', '.join(sorted(supported_voices))}")
    return voice

@app.get("/voices")
async def list_voices():
    """List available voices."""
    return {"voices": list(kokoro.get_voices())}

@app.get("/languages")
async def list_languages():
    """List supported languages."""
    return {"languages": list(kokoro.get_languages())}

@app.post("/tts")
async def text_to_speech(
    text: str = Form(...),
    voice: str = Form("af_sarah"),
    speed: float = Form(1.0),
    lang: str = Form("en-us"),
    format: str = Form("wav")
):
    """Convert text to speech."""
    if format not in ["wav", "mp3"]:
        raise HTTPException(status_code=400, detail="Format must be 'wav' or 'mp3'")
    lang = validate_language(lang)
    voice = validate_voice(voice)
    chunks = chunk_text(text)
    all_samples = []
    sample_rate = None
    for chunk in chunks:
        try:
            samples, sr = kokoro.create(chunk, voice=voice, speed=speed, lang=lang)
            if samples is not None:
                if sample_rate is None:
                    sample_rate = sr
                all_samples.extend(samples)
        except Exception as e:
            raise HTTPException(status_code=500, detail=f"Error processing chunk: {str(e)}")
    if not all_samples:
        raise HTTPException(status_code=500, detail="No audio generated")
    buffer = io.BytesIO()
    sf.write(buffer, all_samples, sample_rate, format=format)
    buffer.seek(0)
    return StreamingResponse(buffer, media_type=f"audio/{format}", headers={"Content-Disposition": f"attachment; filename=output.{format}"})

